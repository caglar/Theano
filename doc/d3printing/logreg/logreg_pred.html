<!DOCTYPE html>
<html>
<head>
	<script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>
	<script type='text/javascript' src="http://cpettitt.github.io/project/dagre-d3/v0.1.5/dagre-d3.min.js"></script>
	<script type='text/javascript' src="http://cpettitt.github.io/project/graphlib-dot/v0.4.10/graphlib-dot.min.js"></script>
</head>

<body>
	<style>
		.svg {
			margin-left:auto;
			margin-right:auto;
			display:block;
			position: fixed;
			border: 0px solid black;
			top:0%; left:0%; right:0% bottom=0%
		}
		.nodeRect {
			stroke: black;
			border: 3px solid black;
		}
		.nodeEllipse {
			stroke: black;
			border: 3px solid black;
		}
		.nodeText {
			color: black;
		}
		.edge {
			stroke: black;
			stroke-width: 3px;
			cursor: pointer;
		}
		.edgeLabelRect {
			stroke: black;
			border: 1px solid black;
			fill: skyblue;
			opacity: 0.9;
		}
		.edgeLabelText {
			fill: black;
			text-anchor: start;
		}
		.arrowHead {
			stroke: black;
			stroke-width: 3px;
			fill: black;
		}
	</style>
	
	
	<script type="text/javascript">
		var width = 1200;
		var height = 900;
		
		// Global attributes
		var pad = 10;
		d3.select('body').select('svg').remove();
		var svg = d3.select('body').append('svg')
			.attr('class', 'svg')
			.attr('width', '100%')
			.attr('height', '100%');
		var pane = svg.append('g');
		
		// Definition head of edges
		svg.append("defs").append("marker")
		    .attr("id", 'edgeArrow')
		    .attr("markerWidth", 6)
		    .attr("markerHeight", 6)
		    .attr("refX", 3)
		    .attr("refY", 3)
		    .attr("orient", "auto")
		  	.append("path")
		    .attr("d", "M0,0 L6,3 L0,6 Z")
		    .attr('style', 'arrowHead');
			
    	function textSize(text, attr) {
    		var t = svg.append('text').text(text);
    		if (typeof(attr) != 'undefined') {
    			for (a in attr) {
    				t.attr(a, attr[a]);
    			}
    		}
    		var bbox = t.node().getBBox();
    		t.remove();
    		return bbox;
    	}
		
		var dotGraph;
		var graph = {};
		var nodes = [];
		var edges = [];
		// d3.text(path, function(dotGraphDef) {

      var dotGraphDef = 'digraph G { 	graph [bb="0,0,728,476"]; 	 	"DimShuffle{x,x}"	 [height=0.5, 		pos="488,194", 		shape=ellipse, 		width=2.0339]; 	"Elemwise{gt,no_inplace}"	 [fillcolor="#FFAABB", 		height=0.5, 		pos="379,106", 		shape=ellipse, 		style=filled, 		width=2.8978]; 	"DimShuffle{x,x}" -> "Elemwise{gt,no_inplace}"	 [label="1 TensorType(float32, (True, True))", 		lp="570.5,150", 		pos="e,423.33,122.35 480.19,176.08 474.48,165.2 465.84,151.39 455,142 448.3,136.19 440.48,131.17 432.44,126.88"]; 	"val=0.5 TensorType(float32, scalar)"	 [fillcolor=limegreen, 		height=0.5, 		pos="510,282", 		shape=box, 		style=filled, 		width=3.0278]; 	"val=0.5 TensorType(float32, scalar)" -> "DimShuffle{x,x}"	 [label="TensorType(float32, scalar)", 		lp="579,238", 		pos="e,492.37,212.08 505.55,263.6 502.49,251.63 498.36,235.5 494.88,221.89"]; 	"DimShuffle{x,0}"	 [height=0.5, 		pos="119,370", 		shape=ellipse, 		width=2.0339]; 	"Elemwise{add,no_inplace}"	 [fillcolor="#FFAABB", 		height=0.5, 		pos="273,282", 		shape=ellipse, 		style=filled, 		width=3.0624]; 	"DimShuffle{x,0}" -> "Elemwise{add,no_inplace}"	 [label="1 TensorType(float64, row)", 		lp="229,326", 		pos="e,198,295.25 125.78,352.01 131.07,340.81 139.47,326.67 151,318 162.05,309.69 175.02,303.35 188.3,298.51"]; 	"name=b TensorType(float64, vector)"	 [fillcolor=limegreen, 		height=0.5, 		pos="111,458", 		shape=box, 		style=filled, 		width=3.0903]; 	"name=b TensorType(float64, vector)" -> "DimShuffle{x,0}"	 [label="TensorType(float64, vector)", 		lp="195,414", 		pos="e,117.41,388.08 112.62,439.6 113.72,427.75 115.2,411.82 116.46,398.29"]; 	dot	 [height=0.5, 		pos="355,370", 		shape=ellipse, 		width=0.75]; 	dot -> "Elemwise{add,no_inplace}"	 [label="0 TensorType(float64, matrix)", 		lp="410,326", 		pos="e,292.35,300.03 342.73,353.87 334.13,343.51 322.22,329.59 311,318 307.43,314.31 303.55,310.52 299.68,306.85"]; 	"name=X TensorType(float64, matrix)"	 [fillcolor=limegreen, 		height=0.5, 		pos="355,458", 		shape=box, 		style=filled, 		width=3.1667]; 	"name=X TensorType(float64, matrix)" -> dot	 [label="0 TensorType(float64, matrix)", 		lp="440,414", 		pos="e,355,388.08 355,439.6 355,427.75 355,411.82 355,398.29"]; 	"name=W TensorType(float64, matrix)"	 [fillcolor=limegreen, 		height=0.5, 		pos="603,458", 		shape=box, 		style=filled, 		width=3.2014]; 	"name=W TensorType(float64, matrix)" -> dot	 [label="1 TensorType(float64, matrix)", 		lp="643,414", 		pos="e,381.63,373 582.96,439.84 568.78,428.57 548.82,414.4 529,406 483.94,386.9 427.82,378.03 391.71,374.04"]; 	Softmax	 [height=0.5, 		pos="276,194", 		shape=ellipse, 		width=1.1472]; 	"Elemwise{add,no_inplace}" -> Softmax	 [label="TensorType(float64, matrix)", 		lp="355,238", 		pos="e,275.4,212.08 273.61,263.6 274.02,251.75 274.58,235.82 275.05,222.29"]; 	Softmax -> "Elemwise{gt,no_inplace}"	 [label="0 TensorType(float64, matrix)", 		lp="370,150", 		pos="e,315.56,120.32 274.93,175.6 275.18,164.8 277.29,151.26 285,142 290.89,134.93 298.36,129.28 306.5,124.78"]; 	"TensorType(int8, matrix)"	 [fillcolor=dodgerblue, 		height=0.5, 		pos="379,18", 		shape=box, 		style=filled, 		width=2.2014]; 	"Elemwise{gt,no_inplace}" -> "TensorType(int8, matrix)"	 [label="TensorType(int8, matrix)", 		lp="450.5,62", 		pos="e,379,36.084 379,87.597 379,75.746 379,59.817 379,46.292"]; } ';
			dotGraph = graphlibDot.parse(dotGraphDef);
			
			// Calculate width and height
			var posMax = [0, 0];
			for (var nodeId in dotGraph._nodes) {
				var node = dotGraph._nodes[nodeId];
				node.value.pos = node.value.pos.split(',').map(function(d) {return parseInt(d);});
				node.value.width = parseInt(node.value.width);
				node.value.height = parseInt(node.value.height);
				posMax[0] = Math.max(posMax[0], node.value.pos[0] + node.value.width);
				posMax[1] = Math.max(posMax[1], node.value.pos[1] + node.value.height);
			}
			dotWidth = posMax[0];
			dotHeight = posMax[1];
			svg.attr('viewBox', '0,0,' + width + ',' + height);
			
			var scaleDotX = d3.scale.linear().domain([0, dotWidth + 100]).range([0, width]);
			var scaleDotY = d3.scale.linear().domain([-25, dotHeight + 100]).range([0, height]);
			
			// Parse nodes
			var i = 0;
			for (nodeId in dotGraph._nodes) {
				var node = dotGraph._nodes[nodeId];
				node.index = i++;
				// x, y is center of node (not corner)
				node.x = scaleDotX(node.value.pos[0]);
				node.y = scaleDotY(dotHeight - (node.value.pos[1] + node.value.height));
				var size = textSize(node.value.label, {'class': 'nodeText'});
				node.value.width = size.width + 2 * pad;
				node.value.height = size.height + 2 * pad;
				node.value.cx = node.value.width / 2;
				node.value.cy = node.value.height / 2;

				node.fixed = true;
				nodes.push(node);
				dotGraph._nodes[nodeId] = node;
			}
			
			// Parse edges
			for (edgeId in dotGraph._edges) {
				var edge = dotGraph._edges[edgeId];
				edge.source = dotGraph._nodes[edge.u].index;
				edge.target = dotGraph._nodes[edge.v].index;
				var size = textSize(edge.value.label, {'class': 'edgeLabelText'});
				edge.value.width = size.width + 2 * pad;
				edge.value.height = size.height + 2 * pad;
				edges.push(edge);
				dotGraph._edges[edgeId] = edge;
			}
			
			// Setup graph
			graph['nodes'] = nodes;
			graph['edges'] = edges;
			
			var isEdgeOver = false;
			var isEdgeLabelOver = false;
			
			// Add edges
			edges = pane.append('g').attr('id', 'edges').selectAll('path').data(graph['edges']).enter().append('path')
				.attr('class', 'edge')
				.attr('marker-mid', 'url(#edgeArrow)')
				.on('mouseover', function(d) {
					var edgeLabel = pane.select('#edgeLabels .' + d.id);
					edgeLabel.attr('style', 'display: inline');
					})
				.on('mouseout', function(d) {
					
					if (!isEdgeLabelOver) {
						var edgeLabel = pane.select('#edgeLabels .' + d.id);
						edgeLabel.attr('style', 'display: none');
					}
					});
			
			// Add edge labels
			edgeLabels = pane.append('g').attr('id', 'edgeLabels').selectAll('g').data(graph['edges']).enter().append('g')
				.attr('style', 'display: none')
				.attr('class', function(d) {return d.id;})
				.on('mouseover', function(d) {
					isEdgeLabelOver = true;
					var edgeLabel = d3.select(this);
					edgeLabel.attr('style', 'display: inline');
				})
				.on('mouseout', function(d) {
					var edgeLabel = d3.select(this);
					edgeLabel.attr('style', 'display: none');
					isEdgeLabelOver = false;
				});

			var edgeLabelsRect = edgeLabels.append('rect')
				.attr('class', 'edgeLabelRect')
				.attr('fill', 'white')
				.attr('width', function(d) {return d.value.width;})
				.attr('height', function(d) {return d.value.height;})
				.attr('rx', 5)
				.attr('ry', 5);
			var edgeLabelsText = edgeLabels.append('text')
				.attr('class', 'edgeLabelText')
				.attr('x', function(d) {return pad;})
				.attr('dy', function(d) {return d.value.height - pad - 5;})
				.text(function(d) {return d.value.label;});
			
			// Add nodes
			nodes = pane.append('g').attr('id', 'nodes').selectAll('g').data(graph['nodes']).enter().append('g');
			function fillColor(f) {
				return typeof(f) == 'undefined' ? 'white' : f;
			}
			nodes.each(function(d) {
				sel = d3.select(this);
				var shape;
				if (d.value.shape == 'ellipse') {
					shape = sel.append('ellipse')
						.attr('class', 'nodeEllipse')
						.attr('cx', d.value.cx)
						.attr('cy', d.value.cy)
						.attr('rx', d.value.width * 0.6)
						.attr('ry', d.value.height * 0.6);

				} else {
					shape = sel.append('rect')
						.attr('class', 'nodeRect')
						.attr('width', d.value.width)
						.attr('height', d.value.height);
				}
				shape.attr('fill', fillColor(d.value.fillcolor));
			});
			var nodesText = nodes.append('text')
				.attr('class', 'nodeText')
				.attr('x', pad)
				.attr('dy', function(d) {return d.value.height - pad - 5;})
				.text(function(d) {return d.value.label;});

			// Update graph
			function updateGraph() {
				// Update nodes
				nodes.attr('transform', function(d) { return 'translate(' + (d.x - d.value.cx) + ' ' + (d.y - d.value.cy) + ')'; });
				// Update edges
				edges.attr('d', function(d) {
					return 'M' + d.source.x + ',' + d.source.y + ' L' + 0.5 * (d.source.x + d.target.x) + ',' + 0.5 * (d.source.y + d.target.y) + ' L' + d.target.x + ',' + d.target.y;
				});
				// Update edge labels
				edgeLabels.attr('transform', function(d) {
					return 'translate(' + (0.5 * (d.source.x + d.target.x - d.value.width)) + ',' + (0.5 * (d.source.y + d.target.y - d.value.height)) + ')';
				});
			}
			
			// Drag-start event handler
			function dragStart(d) {
				d3.event.sourceEvent.stopPropagation();
				d.fixed = true;
			}
			
			// Zoom and translate event handler
			function zoom(d) {
				pane.attr('transform', 'translate(' + d3.event.translate + ') scale(' + d3.event.scale + ')');
			}
			
			// Force layout
			var layout = d3.layout.force()
				.nodes(graph['nodes'])
				.links(graph['edges'])
				.size([width, height])
				.gravity(0.00)
				.charge(-1000)
				.linkDistance(50)
				.linkStrength(0.1)
				.on('tick', updateGraph);
				
			// Drag behavour
			var drag = layout.drag()
				.on('dragstart', dragStart);
			nodes.call(drag);
			
			// Zoom behaviour
			var bZoom = d3.behavior.zoom()
				.scaleExtent([0.2, 8])
				.on('zoom', zoom);
			svg.call(bZoom);
			
			// Start force layout
			layout.start();	
		// });
	</script>
</body>
</html>
