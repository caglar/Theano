<!DOCTYPE html>
<html>
<head>
	<script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>
	<script type='text/javascript' src="http://cpettitt.github.io/project/dagre-d3/v0.1.5/dagre-d3.min.js"></script>
	<script type='text/javascript' src="http://cpettitt.github.io/project/graphlib-dot/v0.4.10/graphlib-dot.min.js"></script>
</head>

<body>
	<style>
		.svg {
			margin-left:auto;
			margin-right:auto;
			display:block;
			position: fixed;
			border: 0px solid black;
			top:0%; left:0%; right:0% bottom=0%
		}
		.nodeRect {
			stroke: black;
			border: 3px solid black;
		}
		.nodeEllipse {
			stroke: black;
			border: 3px solid black;
		}
		.nodeText {
			color: black;
		}
		.edge {
			stroke: black;
			stroke-width: 3px;
			cursor: pointer;
		}
		.edgeLabelRect {
			stroke: black;
			border: 1px solid black;
			fill: skyblue;
			opacity: 0.9;
		}
		.edgeLabelText {
			fill: black;
			text-anchor: start;
		}
		.arrowHead {
			stroke: black;
			stroke-width: 3px;
			fill: black;
		}
	</style>
	
	
	<script type="text/javascript">
		var width = 1200;
		var height = 900;
		
		// Global attributes
		var pad = 10;
		d3.select('body').select('svg').remove();
		var svg = d3.select('body').append('svg')
			.attr('class', 'svg')
			.attr('width', '100%')
			.attr('height', '100%');
		var pane = svg.append('g');
		
		// Definition head of edges
		svg.append("defs").append("marker")
		    .attr("id", 'edgeArrow')
		    .attr("markerWidth", 6)
		    .attr("markerHeight", 6)
		    .attr("refX", 3)
		    .attr("refY", 3)
		    .attr("orient", "auto")
		  	.append("path")
		    .attr("d", "M0,0 L6,3 L0,6 Z")
		    .attr('style', 'arrowHead');
			
    	function textSize(text, attr) {
    		var t = svg.append('text').text(text);
    		if (typeof(attr) != 'undefined') {
    			for (a in attr) {
    				t.attr(a, attr[a]);
    			}
    		}
    		var bbox = t.node().getBBox();
    		t.remove();
    		return bbox;
    	}
		
		var dotGraph;
		var graph = {};
		var nodes = [];
		var edges = [];
		// d3.text(path, function(dotGraphDef) {

      var dotGraphDef = 'digraph G { 	graph [bb="0,0,763,388"]; 	 	"DimShuffle{x,0}"	 [height=0.5, 		pos="600,282", 		shape=ellipse, 		width=2.0339]; 	"Elemwise{add,no_inplace}"	 [fillcolor="#FFAABB", 		height=0.5, 		pos="474,194", 		shape=ellipse, 		style=filled, 		width=3.0624]; 	"DimShuffle{x,0}" -> "Elemwise{add,no_inplace}"	 [label="1 TensorType(float64, row)", 		lp="648,238", 		pos="e,516.94,210.65 587.13,264.21 578.18,253.39 565.47,239.59 552,230 544.1,224.38 535.16,219.35 526.22,214.97"]; 	"name=b TensorType(float64, vector)"	 [fillcolor=limegreen, 		height=0.5, 		pos="607,370", 		shape=box, 		style=filled, 		width=3.0903]; 	"name=b TensorType(float64, vector)" -> "DimShuffle{x,0}"	 [label="TensorType(float64, vector)", 		lp="684,326", 		pos="e,601.39,300.08 605.58,351.6 604.62,339.75 603.32,323.82 602.22,310.29"]; 	dot	 [height=0.5, 		pos="362,282", 		shape=ellipse, 		width=0.75]; 	dot -> "Elemwise{add,no_inplace}"	 [label="0 TensorType(float64, matrix)", 		lp="467,238", 		pos="e,414.72,209.23 365,263.89 367.74,252.92 372.81,239.1 382,230 388.76,223.31 396.93,217.87 405.58,213.46"]; 	"name=X TensorType(float64, matrix)"	 [fillcolor=limegreen, 		height=0.5, 		pos="114,370", 		shape=box, 		style=filled, 		width=3.1667]; 	"name=X TensorType(float64, matrix)" -> dot	 [label="0 TensorType(float64, matrix)", 		lp="273,326", 		pos="e,335.37,285 134.04,351.84 148.22,340.57 168.18,326.4 188,318 233.06,298.9 289.18,290.03 325.29,286.04"]; 	"name=W TensorType(float64, matrix)"	 [fillcolor=limegreen, 		height=0.5, 		pos="362,370", 		shape=box, 		style=filled, 		width=3.2014]; 	"name=W TensorType(float64, matrix)" -> dot	 [label="1 TensorType(float64, matrix)", 		lp="447,326", 		pos="e,362,300.08 362,351.6 362,339.75 362,323.82 362,310.29"]; 	Softmax	 [height=0.5, 		pos="474,106", 		shape=ellipse, 		width=1.1472]; 	"Elemwise{add,no_inplace}" -> Softmax	 [label="TensorType(float64, matrix)", 		lp="554,150", 		pos="e,474,124.08 474,175.6 474,163.75 474,147.82 474,134.29"]; 	"TensorType(float64, matrix) id=6"	 [fillcolor=dodgerblue, 		height=0.5, 		pos="474,18", 		shape=box, 		style=filled, 		width=2.8403]; 	Softmax -> "TensorType(float64, matrix) id=6"	 [label="TensorType(float64, matrix)", 		lp="554,62", 		pos="e,474,36.084 474,87.597 474,75.746 474,59.817 474,46.292"]; } ';
			dotGraph = graphlibDot.parse(dotGraphDef);
			
			// Calculate width and height
			var posMax = [0, 0];
			for (var nodeId in dotGraph._nodes) {
				var node = dotGraph._nodes[nodeId];
				node.value.pos = node.value.pos.split(',').map(function(d) {return parseInt(d);});
				node.value.width = parseInt(node.value.width);
				node.value.height = parseInt(node.value.height);
				posMax[0] = Math.max(posMax[0], node.value.pos[0] + node.value.width);
				posMax[1] = Math.max(posMax[1], node.value.pos[1] + node.value.height);
			}
			dotWidth = posMax[0];
			dotHeight = posMax[1];
			svg.attr('viewBox', '0,0,' + width + ',' + height);
			
			var scaleDotX = d3.scale.linear().domain([0, dotWidth + 100]).range([0, width]);
			var scaleDotY = d3.scale.linear().domain([-25, dotHeight + 100]).range([0, height]);
			
			// Parse nodes
			var i = 0;
			for (nodeId in dotGraph._nodes) {
				var node = dotGraph._nodes[nodeId];
				node.index = i++;
				// x, y is center of node (not corner)
				node.x = scaleDotX(node.value.pos[0]);
				node.y = scaleDotY(dotHeight - (node.value.pos[1] + node.value.height));
				var size = textSize(node.value.label, {'class': 'nodeText'});
				node.value.width = size.width + 2 * pad;
				node.value.height = size.height + 2 * pad;
				node.value.cx = node.value.width / 2;
				node.value.cy = node.value.height / 2;

				node.fixed = true;
				nodes.push(node);
				dotGraph._nodes[nodeId] = node;
			}
			
			// Parse edges
			for (edgeId in dotGraph._edges) {
				var edge = dotGraph._edges[edgeId];
				edge.source = dotGraph._nodes[edge.u].index;
				edge.target = dotGraph._nodes[edge.v].index;
				var size = textSize(edge.value.label, {'class': 'edgeLabelText'});
				edge.value.width = size.width + 2 * pad;
				edge.value.height = size.height + 2 * pad;
				edges.push(edge);
				dotGraph._edges[edgeId] = edge;
			}
			
			// Setup graph
			graph['nodes'] = nodes;
			graph['edges'] = edges;
			
			var isEdgeOver = false;
			var isEdgeLabelOver = false;
			
			// Add edges
			edges = pane.append('g').attr('id', 'edges').selectAll('path').data(graph['edges']).enter().append('path')
				.attr('class', 'edge')
				.attr('marker-mid', 'url(#edgeArrow)')
				.on('mouseover', function(d) {
					var edgeLabel = pane.select('#edgeLabels .' + d.id);
					edgeLabel.attr('style', 'display: inline');
					})
				.on('mouseout', function(d) {
					
					if (!isEdgeLabelOver) {
						var edgeLabel = pane.select('#edgeLabels .' + d.id);
						edgeLabel.attr('style', 'display: none');
					}
					});
			
			// Add edge labels
			edgeLabels = pane.append('g').attr('id', 'edgeLabels').selectAll('g').data(graph['edges']).enter().append('g')
				.attr('style', 'display: none')
				.attr('class', function(d) {return d.id;})
				.on('mouseover', function(d) {
					isEdgeLabelOver = true;
					var edgeLabel = d3.select(this);
					edgeLabel.attr('style', 'display: inline');
				})
				.on('mouseout', function(d) {
					var edgeLabel = d3.select(this);
					edgeLabel.attr('style', 'display: none');
					isEdgeLabelOver = false;
				});

			var edgeLabelsRect = edgeLabels.append('rect')
				.attr('class', 'edgeLabelRect')
				.attr('fill', 'white')
				.attr('width', function(d) {return d.value.width;})
				.attr('height', function(d) {return d.value.height;})
				.attr('rx', 5)
				.attr('ry', 5);
			var edgeLabelsText = edgeLabels.append('text')
				.attr('class', 'edgeLabelText')
				.attr('x', function(d) {return pad;})
				.attr('dy', function(d) {return d.value.height - pad - 5;})
				.text(function(d) {return d.value.label;});
			
			// Add nodes
			nodes = pane.append('g').attr('id', 'nodes').selectAll('g').data(graph['nodes']).enter().append('g');
			function fillColor(f) {
				return typeof(f) == 'undefined' ? 'white' : f;
			}
			nodes.each(function(d) {
				sel = d3.select(this);
				var shape;
				if (d.value.shape == 'ellipse') {
					shape = sel.append('ellipse')
						.attr('class', 'nodeEllipse')
						.attr('cx', d.value.cx)
						.attr('cy', d.value.cy)
						.attr('rx', d.value.width * 0.6)
						.attr('ry', d.value.height * 0.6);

				} else {
					shape = sel.append('rect')
						.attr('class', 'nodeRect')
						.attr('width', d.value.width)
						.attr('height', d.value.height);
				}
				shape.attr('fill', fillColor(d.value.fillcolor));
			});
			var nodesText = nodes.append('text')
				.attr('class', 'nodeText')
				.attr('x', pad)
				.attr('dy', function(d) {return d.value.height - pad - 5;})
				.text(function(d) {return d.value.label;});

			// Update graph
			function updateGraph() {
				// Update nodes
				nodes.attr('transform', function(d) { return 'translate(' + (d.x - d.value.cx) + ' ' + (d.y - d.value.cy) + ')'; });
				// Update edges
				edges.attr('d', function(d) {
					return 'M' + d.source.x + ',' + d.source.y + ' L' + 0.5 * (d.source.x + d.target.x) + ',' + 0.5 * (d.source.y + d.target.y) + ' L' + d.target.x + ',' + d.target.y;
				});
				// Update edge labels
				edgeLabels.attr('transform', function(d) {
					return 'translate(' + (0.5 * (d.source.x + d.target.x - d.value.width)) + ',' + (0.5 * (d.source.y + d.target.y - d.value.height)) + ')';
				});
			}
			
			// Drag-start event handler
			function dragStart(d) {
				d3.event.sourceEvent.stopPropagation();
				d.fixed = true;
			}
			
			// Zoom and translate event handler
			function zoom(d) {
				pane.attr('transform', 'translate(' + d3.event.translate + ') scale(' + d3.event.scale + ')');
			}
			
			// Force layout
			var layout = d3.layout.force()
				.nodes(graph['nodes'])
				.links(graph['edges'])
				.size([width, height])
				.gravity(0.00)
				.charge(-1000)
				.linkDistance(50)
				.linkStrength(0.1)
				.on('tick', updateGraph);
				
			// Drag behavour
			var drag = layout.drag()
				.on('dragstart', dragStart);
			nodes.call(drag);
			
			// Zoom behaviour
			var bZoom = d3.behavior.zoom()
				.scaleExtent([0.2, 8])
				.on('zoom', zoom);
			svg.call(bZoom);
			
			// Start force layout
			layout.start();	
		// });
	</script>
</body>
</html>
